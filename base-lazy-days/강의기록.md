# React Query

## install

```npm i @tanstack/react-query
@tanstack/react-query-devtools

npm i -D @tanstack/eslint-plugin-query
```

devtools을 dev dependency로 하지 않는 이유 : 앱 컴포넌트들에서 dev tools를 가져와 추가한 다음 dev tools를 사용하여 node 환경을 테스트하고 node 환경이 development인 경우 이를 포함하지 않기 때문

---

## 중앙 집중식 Fetching Hook

각 컴포넌트에 대해 개별 로딩 인디케이터를 사용하는 대신
중앙 집중식 로딩 인디케이터를 사용하는게 좋다.

### useIsFetching

- `useIsFetching`은 현재 가져오기 상태인 쿼리 호출의 수를 나타내는 정수를 반환.
- isFetching이 0보다 크면 페칭 상태의 호출이 있으며 True로 평가된다는 의미.

예시 `client / src/ App / <Loading/>` 컴포넌트에 작성함

## queryClient 에 대한 OnError 기본 값

Q. 왜 useError은 없는가?
-> 각 오류에 대한 메세지를 표시해야하기 때문에 useIsFetching처럼 기본 훅을 제공하지 않는 것으로 보임.

```tsx
const queryClient = new QueryClient({
  queryCache: new QueryCache({
    onError: (error) => {
      //handle Error
    },
  }),
});
```

`base-lazy-days/client/src/react-query/queryClient.ts` 에 로직 작성

## prefetchQuery

- useQuery 호출에서 가져오는 방식과 같음.
- 예시
  HOME 에서 Treatment data를 prefetching 해줄 것.
  Q. "홈 컴포넌트가 렌더될 때마다 prefetch를 실행해도 괜찮을까?"
  A. 렌더링이 자주 일어나지 않고, queryKey가 동일하다면 캐시가 유지되어 재요청은 없음.

  Q. "왜 useEffect 안에서 훅을 사용하지 않는가?"
  A. prefetchQuery는 훅이 아닌 일반 함수이므로 useEffect 안에서 실행 가능하지만,
  만약 prefetch에 의존하는 쿼리를 즉시 사용한다면 useQuery처럼 훅으로 작성되어야 함.

## 의존성 배열로서의 쿼리 키

```tsx
const { data } = useQuery({
  queryKey: [queryKeys.appointments, monthYear.year, monthYear.month], //쿼리키에 고유한 배열 추가
  queryFn: () => getAppointments(monthYear.year, monthYear.month),
});
```

- queryKey는 React Query에서 데이터를 캐싱하고 추적하는 기준
- queryKey가 변경되면 새로운 쿼리로 인식하여 데이터를 다시 가져온다.
  따라서, 날짜와 같이 동적으로 변경되는 값을 쿼리 키에 포함시켜야 제대로 작동
- 즉, 키를 종속성 배열로 처리해야 함
